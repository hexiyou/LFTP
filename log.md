# 项目日志

## 11-15

初步规划：

要求使用 UDP 实现 TCP，首先需要学会 UDP 和 TCP。比较犹豫的就是我该不该在现在就开始看《Unix网络编程》，还是从简单的代码入手。我进行了一下思考和资料的查阅，觉得如果我要深入学习Java后端，那我现在肯定要先将Java的内容好好啃下来。同时既然我需要学习Java，我不妨就从推荐的书目开始学起（见技术新知 11-15）。但在下载了推荐书目进行一番浏览后发现，Java基础内容中对套接字并没有太多叙述。所以我又得转回C语言（UNP），好好啃书。

关于UNP我存在着一些疑惑：C语言是如何实现套接字API的？其实现方法在不同平台（Unix、Linux、Windows）是否有差别？其实现方法和其他语言又有什么差别？希望这些疑惑可以在我阅读的过程中一一得到解答。

另外，我的Go作业也需要进行网络服务的编程——但这应该是直接使用HTTP协议的了

同时，现在我对于UDP、TCP的理论知识还不完善，因此需要重新仔细看一遍计网教材。在这个过程中应该列出一个（或多个）脑图，分析要用UDP实现TCP具体是哪些方面，然后不断给这些方面填充具体的内容和实现方法。

# 11-22

- 找到了一段大文件复制读写的代码： filestream/IOliu.java
- 找到了UDP传输的代码：udp/
- 尝试拼接到一起，实现udp的不可靠大文件传输

尝试成功进行传输，但存在着很大的问题：比如传一个文本，中间出现了断层！

停止判断不能在接收端使用：```while(!packet.getData().equals(end));```，原因不明

出现了大量的丢包。

# 11-27 

今天的目标是实现多客户端的UDP不可靠传输；大概思路如下：

- Server会固定一个监听端口，然后在每次收到报文的时候，回传一个新的端口给Client；
- 同时分配一个线程监听这个新的端口，进行数据的传输
- 在客户端使用Thread.sleep降低传输速率。

在传输的时候卡住了，原因不明。

# 11-29

今天先解决一下上次遗留下来的问题。
备忘： 
- Server: arg0为文件名
- Client: arg0为端口，arg1为文件名

检查到原来是忘了给packet设置addr和port; 单用户测试成功；多用户测试成功。

`fos.write(packet.getData(), 0, 64);`出现报错，原因不明；<br>
将64改成 `packet.getData().length`，出现了很多乱码<br>
检测出问题是在 **接收方**，当发送完一个packet以后，packet的`offset`和`len`都固定了，要重新`setData`重置为64（magic number for now)<br>

至此，多用户UDP传输测试成功！，<br>
今日的下一个目标是实现基本的LFTP(本项目协议名)框架，即实现Client可以选择上传或者下载文件；<br>
先确立一下**协议的格式**。

## 协议的定义分析

- TCP数据包包含了 src port & dst port; 但由于这里使用udp实现tcp, 端口在udp包里也是有的，所以LFTP协议内无需包含端口号
- ACK, SEQ, CheckSum 需保留用于提供可靠传输
- Window 用于流量控制&阻塞控制，其值是 rwind 和 cwind 当中的较小值
- 协商最大报文需要一个MSS进行阻塞控制(?)
- Data size, Data段

> 在做到最后的时候要注意留多一些时间给协议逐字段debug

为了降低一定的编写难度（在不失基本的TCP仿真性的基础上），打算用以下方式对LFTP协议进行简化：

- 由于连接中不存在双工数据传输的情况，因此每次传输过程中**发送方只发SEQ而接收方只发ACK**
- 超时间隔初始为1s，且暂定为不在超时发生时double
- 接收区缓存 & 发送区缓存 设置为固定的常量；需要做流量控制的时候可以修改
- 接收端: 收到超前包的时候丢弃; 发送端：因此不会收到乱序的ACK，也就无需在超时时候选择GBN还是Selective Repeat。


暂时没想到其他需要的；<br>
完成了协议的简单定义以后，今天下一个任务是 **实现udp的发送接收**

# 12-1 

今日的第一个目标是按照指令格式实现udp版本的上传和下载文件。

- 发送文件: `java Client lsend myserver mylargefile`
- 接收文件: `java Client lget myserver mylargefile`
- 约定Server的监听端口为6060

主要难点:

- Client、Server寻找可用端口
- IP地址解析